# 학습 내용
- 동시성 프로그래밍

# Task 란 무엇인가?

바라보는 관점에 따라 다르게 정의될 수 있다.
입장이 두가지 있다고 생각해보자.

동시성 프로그래밍 입장에서는 Task == **클로저** 
병렬 프로그래밍 입장에서는 Task = **프로세스** 

## 동시성 프로그래밍

- Swift 입장
- 코어는 하나고 멀티 쓰레드
- 소프트웨어적 쓰레드에서 일을 처리하는 논리적인 개념
- 한 코어가 엄청 빠르게 여러 일을 처리하는 것
- Task == **클로저**

## 병렬 프로그래밍

- 운영체제(iOS, MacOS) 입장
- 멀티 코어
- Task = **프로세스**

*운영체제의 역할? 
하드웨어를 다루는 일을 함 : 모니터, 스피커.. 등 관리

그래서 운영체제의 입장에서는 Task 하나가 프로세스라고 할 수 있음 

쓰레드의 구성
프로세스 → 프로세스 내의 쓰레드 → 운영체제 → CPU → CPU내의 쓰레드 

# DispatchQueue

개발자가 할일은 작업을 어떤식으로 처리할지 **2가지**만 정해서 DispatchQueue에 넘겨주면 끝

그러면 시스템이 알아서 필요한 스레드 만들고 작업을 처리해준다.

## 우리가 정해줄 2가지는?

- 직렬인지 동시성인지 : 스레드 하나만 쓸거야 여러개 쓸거야
- 동기인지 비동기인지 : 작업 끝나는거 기다릴거야 말거야

4개의 조합이 나올 수 있음

1. 직렬 + 동기 `DispatchQueue.main.sync`
2. 직렬 + 비동기 `DispatchQueue.main.async`
3. 동시성 + 동기
4. 동시성 + 비동기 

### 직렬과 동시성

#### Serial이란? 

**단일** 스레드에서 순차적으로 일이 실행된다는 뜻이다. 보통 순서가 중요한 일일때 쓴다. 

- 순서 0
- 실행 종료시점 0 → 작업이 종료되고 할일 정해주기 가능

#### Concurrent란? 

**다중** 스레드로 일이 분배되어 실행된다. (순서 알수 없고, 언제 끝날지도 모름)

- 순서 X
- 실행 종료시점 X → 작업이 종료되고 할일 정해주기 불가능

### 동기와 비동기

async / sync 란? 작업을 보내는 입장에서 기다릴지말지 결정하는 것 

#### sync 

작업을 보내고 딴 작업 못함 .. 보낸 작업이 끝나야 다음작업 시작 가능 

#### async

작업을 보내고 끝나든 말든 관심없고 다음작업 시작가능 

## 디스패치큐 종류는?

3가지로 볼 수 있다. 각각의 디스패치큐는 직렬이거나 동시성의 속성을 가진다.

- main
- global
- custom

#### 전제 조건
- 메인큐는 Serial 방식으로 동작한다

- 글로벌큐는 Concurrent하게 동작한다.

- 커스텀큐의 디폴트 동작방식은 Serial이다. (Concurrent로 설정 변경도 가능)

# 메인 스레드는 뭐지?

앱이 실행되는 동안은 늘 메모리에 올라가있는 기본 스레드
메인 스레드가 멈추면 앱이 멈추는 것과 동일하다
메인 스레드는 기본으로 늘 메모리에있고, 필요한 만큼 다른 스레드들을 생성하는 방식
필요에 의해 만들어진 다른 스레드들은 자기 일을 다하면 사라진다.  

### 직렬(하나의 스레드) 환경에서 비동기는 어떻게 하는건가?

스레드가 하난데 어케 안 기다리고 다른일을 하는거지? 라는 의문이 들수가 있다.

이런 경우를 생각해보자.

메인스레드가 메인큐에 비동기로 일을 보내고, 그 다음 코드가 그냥 메인스레드에서 동작하는 코드인 상황

메인스레드는 비동기적으로 작동하는 코드는 큐에보내고 안기다리고 다음코드를 진행한다. 

동시에 두작업을 처리할 수 없기때문에 큐에보냈다가 다시 돌아온 코드는 현재코드가 다 끝날때까지 기다려야함

예제를 보자

```swift
//1
DispatchQueue.main.async {
    for _ in 1...5 {
        print("😀😀😀😀😀")
    }
}

//2
for _ in 1...5 {
    print("🥶🥶🥶🥶🥶")
}
```
#### 실행순서
메인스레드에서 일단 모든 코드를 판단하니까
1st 메인스레드에서 1(노랑이)을 하나의 스레드만 가진 메인큐에 비동기로 보내면
2nd 메인큐에서 메인스레드로 다시 처리하라고 1(노랑이)을 보냄
3rd 메인쓰레드는 그 와중에 1(노랑이)을 보내고나서 1이 어케되든 안기다리고 2(파랑이)인 다음 일 진행하는 중 
4th 2끝나고 그제서야 1이실행됨

#### 결론
그래서 대개... 2(파랑이)가 먼저 실행되고, 1(노랑이)가 그 다음에 실행되는 것 

(만약 1(노랑이)이 개빨리 메인스레드로 다시 돌아온다면..? 노랑이가 먼저 실행될수도 있음 참나)

# 그림으로 헷갈리는 상황들 비교
![https://s3.ap-northeast-2.amazonaws.com/media.yagom-academy.kr/resources/6152fa94ccd9ef11a51aee7f/61bec37de4081120ba786c44.png](https://s3.ap-northeast-2.amazonaws.com/media.yagom-academy.kr/resources/6152fa94ccd9ef11a51aee7f/61bec37de4081120ba786c44.png)

```swift
//1. 커스텀 직렬(serial)큐에 보내는 경우
DispatchQueue(label: "aa").sync {
    print("a")
}

//2. 메인(serial)큐에 보내는 경우 -> 에러
//DispatchQueue.main.sync {
//    print{"b"}
//}

//3.
DispatchQueue.global().async {
    DispatchQueue.main.sync {
        print("c")
    }
}

//4. 에러
//DispatchQueue.global().sync {
//    DispatchQueue.main.sync {
//        print("d")
//    }
//}
```

### 1번코드가 되는이유는?

`DispatchQueue(label: "aa").sync`
 커스텀큐는 serial 방식이 디폴트 설정임 그래서 메인큐와 동일하게 단 하나의 스레드를 가지고 순차적으로 동작함

근데 메인에서 보내는 `DispatchQueue.main.sync {}` 얘는 안되고, 얘는 왜 되냐

1. 모든 코드는 메인 스레드에서 시작
2. 커스텀큐로 일을 보낸다
3. 커스텀큐는 커스텀 스레드(단하나)로 일을 보낸다.
4. 커스텀 스레드에서 일을 끝내고 다시 메인 스레드로 돌아온다. (메인은 커스텀 스레드의 일이 끝날때까진 블락인데 커스텀 스레드에서 일을 끝내고 돌아오면 다시 동작중인것이다)

### 2번코드 에러나는 이유

`DispatchQueue.main.sync {}` 

1. 모든 코드는 메인 스레드에서 시작
2. 메인큐로 일을 보낸다

이때, 일을 보내는 방식이 동기(sync)라서 보낸 일이 끝날때까지 메인스레드는 기다려야댐 

따라서 메인 스레드는 큐에 일을 보내놓고 block상태가 됨 (보낸 일이 다 끝날때까지 기다리는중)

1. 메인큐는 다시 메인 스레드로 일을 보낸다
2. 메인스레드는 보내놓은 일이 끝날때까지 기다리고 있는데, 그 일이 돌아와서 자기를 처리해달라고 하니깐...
3. 메인큐는 일이끝날때까지 기다리고, 일은 큐에서 일어나는 일(사실 자긴데)이 끝날때까지 서로 기다리고 있는 상황이 발생함,, 

### 그럼 3번코드가 되는이유는?

`DispatchQueue.global().async {` 안에서  `DispatchQueue.main.sync {` 가 실행된다면,

1. 모든 코드는 메인 스레드에서 시작
2. 글로벌큐로 일을 보낸다

이때, 글로벌큐로 일을 보내는 방식이 비동기라서 메인스레드는 보낸 일이 끝나든 말든 자기할일중

1. 글로벌큐는 글로벌 스레드들로 일을 보낸다 
2. 글로벌 스레드에서 main.sync 가 실행되면 일이 메인큐로 가고 
3. 이때 저 일을 보낸 글로벌 스레드는 일이 끝나기를 기다리나? yes → 현재 context가 기다리기때문
4. 메인큐는 메인스레드로 일을 보내서 실행이 된다.  (메인스레드가 정상적으로 동작하고 있어서 일을 받을수있음)

### 4번코드 에러나는 이유

`DispatchQueue.global().sync` 안에서 `DispatchQueue.main.sync` 가 실행된다면,

1. 모든 코드는 메인 스레드에서 시작
2. 글로벌큐로 일을 보내고 메인스레드는 그 일이 끝날때까지 기다리는 상태
3. 글로벌큐는 글로벌 스레드들로 일을 보낸다
4. 글로벌 스레드에서 main.sync가 실행되면 일이 메인큐로 가는데
5. 이때 메인큐는 2에서 보낸 일이 끝날때까지 기다리는 block상태... 일 못받음 그래서
6. 4에서 일을 보낸 글로벌 스레드도 일 보내고 기다리는 상태... 
7. 데드락


