# TIL 1122

# 활동학습

## Q : ARC는 무엇인가?
메모리 사용량을 추적할 수 있고 관리하는 것이다.
참조 타입인 클래스와 클로져는 Heap 영역을 접근할 수 있는데, 접근할 때 카운트를 관리해준다.
ARC 는 컴파일러 기능인데 Objective-C 오브젝트에 대하여 자동으로 메모리 관리를 제공해준다.
retain 과 release 연산을 하기보다는 ARC 를 활용하여 본래 코드에 집중할 수 있도록 도와준다.
Transitioning to ARC Release Notes

## Q : ARC 이전의 메모리 관리는 어땠을까?
Objective-C 환경에서 MRC 를 사용했다.
인스턴스를 생성하는 시점에서는 자동으로 reference count 를 올려줬으나…
다른 변수에 reference 값을 넘겨줄 때 reference count 를 조정해주는 작업을 수동으로 해줘야 했다.
이 때 사용된 개념이 retain 과 release 였다.

## Q : ARC를 이해해야 하는 이유는 무엇 무엇이 있을까?
Strong Reference Cycles 상황이 발생할 수 있는데 해결할 수 있는 방법을 개발자가 알고 있어야 한다.
메모리 누수가 발생할 수 있는 상황을 예방할 수 있다.

## Q : 언제 구조체를 선택하고 언제 클래스를 선택해야할까?
같은 인스턴스를 공유하는가? 공유하지 않는가?
Objective-C 코드와 클래스를 혼용할 수 있는데 ARC 때문일 수 도 있을 것이다.


## **ARC는 retain 과 relese 코드를 컴파일 시점에 삽입해주는 일밖에 안한다 !!!**

ARC 가 없었을 때에는 MRC로 프로그래머가 한땀한땀 코드를 작성해야했음

**retain - release**
메모리 카운트 올릴때 retain
메모리 카운트 내릴때 release

인스턴스 하나 만들때마다 코드 최소 두줄 생성

근데, 알아서 코드를 삽입해주는 ARC 등장 !!

예전보다는 retain - release 를 자세히 알아야한다는 의무는 줄었지만,,

그래도 모르고 쓰면 메모리 낭비, 성능에 악영향을주는 일을 할 수 있으니 프로그래머가 알고 코드를 작성해야한다.

이 ARC가 어떻게 작동하기때문에 메모리에 남아있을것이고 그래서 누수가 발생한다는 것을 알아야함

### GC

프로그래머가 이해를 안해도된다는 장점 → 리스크가 될 수 있음(메모리 관리의 키를 전적으로 쥘 수 없음)

이거 나중에 쓸것같은데? 하면 안버림 

최대한 보수적으로 가져감 

애매하면 냅두고, 그걸 판단하는데도 비용이든다. 

프로그래머가 의도적으로 완벽하게 제어 불가능 

그러나 ARC는 프로그래머가 완벽히 제어가능.

### LinkedList
step 1 에서 사용하지 않았던 링크드리스트를 구현하는 방법을 배웠다. 

일단 next 프로퍼티를 가지고 있는 Node 클래스를 만든 후에, front 와 rear 프로퍼티를 가지는 LinkedList 클래스를 만들어서 만약에 rear 가 nil이면, rear과 front 모두에게 Node() 인스턴스를 할당해주고, nil이 아니라면 rear?.next 에 새로운 Node() 인스턴스를 할당해주는 방식으로 새로운 node를 추가한다. 

node를 빼는 방법은 front에 있는 node를 리턴하고, front를 front?.next 로 옮겨주는 방식을 사용한다. 


