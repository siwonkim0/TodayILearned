# 학습내용

## 타입(Type: 유형)과 인스턴스

: 집 설계도와 설계도로 지은 집들

![스크린샷 2021-08-21 오전 1.25.27.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e0181b24-4f20-45b7-9315-9dc043a23c80/스크린샷_2021-08-21_오전_1.25.27.png)

![타입에는 속성(변수)과 메소드(함수)가 있다.](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/36338f9f-26d5-48fe-99bb-ef3aa84c26dd/스크린샷_2021-08-21_오전_1.26.51.png)

타입에는 속성(변수)과 메소드(함수)가 있다.

![스크린샷 2021-08-21 오전 1.31.26.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/76e33d49-5a92-458c-a187-26f92f7fd58a/스크린샷_2021-08-21_오전_1.31.26.png)

![스크린샷 2021-08-21 오전 1.33.38.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5086f5df-9f15-4bc9-aa2b-0402ced694e9/스크린샷_2021-08-21_오전_1.33.38.png)

속성(property)의 종류에는 타입 프로퍼티, 인스턴스 프로퍼티가 있음.
메소드(method)의 종류에도 타입 메소드와 인스턴트 프로퍼티가 있음.
→ 근데 지금부터 말할 프로퍼티와 메소드는 인스턴트 프로퍼티와 인스턴트 메소드를 의미한다.

## 타입의 정의

타입의 종류 세가지

- 열거형(Enumeration) : 지난시간에 함
- 구조체(Struct)
- 클래스(Class)

```swift
//House 라는 이름의 구조체 정의 (struct -> class라고만 바꾸면 클래스 타입임)
struct House {
    var color: UIColor = UIColor.blue
    let bedrooms: Int = 2

    func runWater() {
        print("물이 콸콸콸")
    }

    func turnLightsOn() {
        print("불을 켰습니다")
    }

    func openGarageDoor() {
        print("주차장 문이 열립니다")
    }
}
```

```swift
var myHouse: House = House() // House 타입의 인스턴스 myHouse 생성
myHouse.color = UIColor.green()
myHouse.openGarageDoor()
//myHouse.bedrooms = 3 오류 : let 으로 정의되어 바꾸면 안됨

var herHouse: House = House() // House 타입의 인스턴스 herHouse 생성
herHouse.color = UIColor.yellow
herHouse.turnLightsOn()
```

### 구조체 Struct

스위프트 대부분 타입은 구조체로 이루어졌다. 

구조체는 **값** 타입. ~~(뭔진 아직 모름)~~  :값 타입으로 값을 넘기면 전달될 값이 복사되어 넘어간다.

*스위프트의 기본 타입 : String, Bool, Array, Int, Dictionary, Set 등 모두 구조체

*그러나 대다수 사용자 정의 데이터 타입은 클래스로 구현됨

타입 이름은 대문자 카멜케이스 사용하여 짓는다. (프로퍼티, 메서드는 소문자 카멜케이스)

```swift
struct 이름 {
    /* 구현부 */
}
```

- 프로퍼티 및 메서드 구현

```swift
struct Sample {
    var mutableProperty: Int = 100 //가변 프로퍼티

    let immutableProperty: Int = 100 //불변 프로퍼티

    static var typeProperty: Int = 100 //타입 프로퍼티

    func instanceMethod() { //인스턴스 메서드
        print("instance method")
    }
    static func typeMethod() { //타입 메서드
        print("type method")
    }
}
```

- 구조체 사용

```swift
var mutable: Sample = Sample() //가변 인스턴스

mutable.mutableProperty = 200
//mutable.immutableProperty = 200 오류: 불변 프로퍼티는 인스턴스 생성 후 수정이 불가능

let immutable: Sample = Sample() //불변 인스턴스

//immutable.mutableProperty = 200 오류: 불변 인스턴스는 아무리 가변 프로퍼티라도 수정 불가능
//immutable.immutableProperty = 200

Sample.typeProperty = 300 //타입 프로퍼티
Sample.typeMethod() //타입 메서드

//mutable.typeProperty = 400 오류: 인스턴스에서는 타입 프로퍼티 사용 불가능
//mutable.typeMethod() 오류: 인스턴스에서는 타입 메서드 사용 불가능
```

- 사용 예시 : 학생 Student 구조체 만들어보기

```swift
struct Student {
    var name: String = "unknown"
    var classs: String = "Swift"
    static func selfIntroduce() { //타입 메서드
        print("학생타입입니다.")
    }
    func selfIntroduce() { //인스턴스 메서드
        print("저는 \(self.classs)반 \(name)입니다.")
    }
}

Student.selfIntroduce() //학생타입입니다.

var yagom: Student = Student() //가변 인스턴스 생성
yagom.name = "yagom"
yagom.classs = "스위프트"
yagom.selfIntroduce() //저는 스위프트반 yagom입니다.

let jina: Student = Student() //불변 인스턴스 생성
//jina.name = "jina" 오류: 불변 인스턴스이므로 프로퍼티 값 변경불가
jina.selfIntroduce() //저는 Swift반 unknown입니다. -> 불변 인스턴스이므로 그대로
```

- 사용 예시: 열거형을 통해 한정된 선택지 만들어주기

구조체의 메서드에서 프로퍼티 값을 변경하려면 mutating을 앞에 붙여줘야한다.

```swift
enum Fuel {
    case gasoline, diesel
}

enum Direction {
    case left, right
}

enum Gear {
    case forward, reverse
}

struct Car {
    var color: UIColor = .red
    var fuel: Fuel = .gasoline
    var capacity: Int = 5
    var gear: Gear = .forward

    // 구조체의 메소드에서 프로퍼티 값을 변경하려면 mutating을 앞에 붙여줘야합니다
    mutating func goForward() {
        gear = .forward
        print("전진")
    }

    // 구조체의 메소드에서 프로퍼티 값을 변경하려면 mutating을 앞에 붙여줘야합니다
    mutating func reverse() {
        gear = .reverse
        print("후진")
    }

    func turn(to: Direction) {
        print("\(to)로 회전")
    }
}

var greenCar: Car = Car()
greenCar.color = .green
greenCar.fuel = .diesel
greenCar.goForward()

var yellowCar = Car.init()
yellowCar.color = .yellow
yellowCar.turn(to: Direction.left)
```

### 클래스 class

클래스는 참조 타입(구조체는 값타입이었는데...) 

타입 이름은 대문자 카멜케이스로 정의

```swift
class 이름 {
    /* 구현부 */
}
```

- 프로퍼티 및 메서드 구현

```swift
class Sample {
    var mutableProperty: Int = 100    // 가변 프로퍼티

    let immutableProperty: Int = 100    // 불변 프로퍼티

    static var typeProperty: Int = 100    // 타입 프로퍼티

    func instanceMethod() {    // 인스턴스 메서드
        print("instance method")
    }

    **// 타입 메서드**
    static func typeMethod() {    // 재정의 불가 타입 메서드 - static
        print("type method - static")
    }

    class func classMethod() {    // 재정의 가능 타입 메서드 - class
        print("type method - class")
    }
}
```

- 클래스 사용

클래스는 구조체와 다르게 let과 var을 사용한 인스턴스 모두가 가변 프로퍼티를 변경해줄 수 있다. 

왜? 클래스의 인스턴스는 참조 타입이므로 let으로 선언되어도 인스턴트 프로퍼티의 값 변경이 가능

```swift
var mutableReference: Sample = Sample()// 인스턴스 생성 - 참조정보 수정 가능

mutableReference.mutableProperty = 200
//mutableReference.immutableProperty = 200 오류: 불변 프로퍼티는 인스턴스 생성 후 수정 블가능

let immutableReference: Sample = Sample() // 인스턴스 생성 - 참조정보 수정 불가

immutableReference.mutableProperty = 200 
// 클래스의 인스턴스는 참조 타입: let이라도 인스턴스 프로퍼티 값 변경 가능
// immutableReference.immutableProperty = 200 오류: 참조 타입이라도 불변 인스턴스는 수정 불가능

//immutableReference = mutableReference 오류: 참조 정보는 변경 불가능
```

```swift
// 타입 프로퍼티 및 메서드
Sample.typeProperty = 300
Sample.typeMethod() // type method

// 인스턴스에서는 타입 프로퍼티나 타입 메서드를
// 사용할 수 없습니다
//mutableReference.typeProperty = 400
//mutableReference.typeMethod()
```

- 사용 예시: 학생 클래스 Class 만들어보기

```swift
class Student {
    var name: String = "Unknown" //가변 프로퍼티
    var classs: String = "Swift"
    func selfIntroduce() { //인스턴스 메서드
        print("저는 \(self.classs)반 \(name)입니다.") //self는 자기 자신을 지칭(사용은 선택)
    }
    class func selfIntroduce() { //타입 메서드
        print("학생타입입니다.")
    }
}

Student.selfIntroduce() //타입 매서드 사용 : 학생타입입니다.

//인스턴스 생성
var yagom: Student = Student()
yagom.name = "yagom"
yagom.classs = "스위프트"
yagom.selfIntroduce() //저는 스위프트반 yagom입니다.

//인스턴스 생성
let jina: Student = Student()
jina.name = "jina"
jina.selfIntroduce() //저는 Swift반 jina입니다.

```

### 실습

동물이 공통적으로 갖는 특성은 무엇이 있을까요? 또, 동물이 공통적으로 할 수 있는 동작은 무엇이 있을까요? 동물을 표현한 Animal 타입을 구현해보세요.

```swift
enum Feet {
    case two, four
}
enum Kind {
    case bird, mammal, reptile, fish
}
enum Skin {
    case fur, scale, feather
}

struct Animal {
    var feet: Feet = .two
    var kind: Kind
    var skin: Skin
    
    func walk() {
        print("걸어가는중")
    }
    func run() {
        print("뛰어가는중")
    }
    func turnAround() {
        print("한바퀴 도는중")
    }
}

var cat: Animal = Animal(kind:.bird, skin:.fur) //아 프로퍼티 기본값을 할당해놓지 않아서 여기서 쓰라고 요구했구나 
cat.feet = .four
cat.turnAround()
print(cat)
```
## <값 타입과 참조 타입>

구조체는 값타입, 클래스는 참조 타입
값 타입과 참조 타입의 가장 큰 차이점은 "무엇이 전달되느냐"이다. 

- **값 타입**
값 타입으로 값을 넘기면 전달될 값이 복사되어 넘어간다.

- **참조 타입**
참조 타입으로 값이 전달되면 값을 복사하지 않고 주소가 전달된다. (주소 를 전달 = **메모리 위치** 를 전달하는 것)


## Class vs Struct

<공통점>

1. 여러 변수를 담을 수 있는 컨테이너다
2. 데이터를 용도에 맞게 묶어 표현하고자 할 때 용이하다
3. 하나의 새로운 사용자정의 데이터 타입을 만들어준다
4. 초기화를 정의하여 초기 상태를 설정할 수 있다
5. 확장/프로토콜 사용/서브스크립트 사용 가능하다 (이건 아직 모름)

<차이점>

1. 클래스는 참조 타입 vs  구조체는 값 타입 (함수의 전달인자로 값을 넘기거나, 다른 변수나 상수에 할당 할 때 값을 복사해서 넘기느냐 아니면 값의 주소가 전달되느냐의 차이)
2. 클래스만 **상속**가능 (*상속이 뭐지)
- 상속이란?
    
    기반클래스를 다른 클래스에서 물려받는 것
    
    부모클래스의 메서드, 프로퍼티를 재정의하거나, 기반클래스의 기능이나 프로퍼티를 물려받고 자신의 기능을 추가할 수 있다. 
    
    *기반 클래스: 다른 클래스로부터 상속을 받지 않은 클래스
    
1. **타입캐스팅**은 클래스의 인스턴스만 허용된다 (* 타입캐스팅이 뭐지)
- 타입캐스팅이란?
    
    타입캐스팅은 인스턴스의 타입을 확인하거나 인스턴스를 같은 계층(hierachy)에 있는 다른 superclass나 subclass로 취급하는 방법입니다. 타입캐스팅에는 is와 as 두 연산자를 사용합니다. 타입캐스팅을 이용하면 특정 프로토콜을 따르는지(conforms) 확인할 수도 있습니다.
    
    [타입캐스팅 (Type Casting)](https://jusung.gitbook.io/the-swift-language-guide/language-guide/18-type-casting)
    
1. **디이니셜라이저** deinit는 클래스의 인스턴스에만 사용가능하다 (참조타입인 클래스의 인스턴스는 더이상 참조할 필요가 없을 때 메모리에서 해제되는데, 이렇게 소멸되기 직전에 deinit이 호출됨)
2. **참조횟수 계산**은 클래스의 인스턴스에만 적용된다
3. 구조체는 사용자 정의 이니셜라이저를 구현하지 않는다면, 멤버와이즈 이니셜라이저를 기본 제공(클래스는 X) *멤버와이즈 init: 프로퍼티의 이름으로 매개변수를 갖는 이니셜라이저
4. 구조체는 구조체 안에서 메서드로 프로퍼티 값을 바꾸려면 **mutating func**를 사용해야한다. 

값 타입의 프로퍼티들은 애초에 인스턴스 메서드로 바꿀 수 없기때문에 mutatting을 써줘야 하는 것. 클래스는 그냥 바꿔줘도 됨 → 역시 클래스는 참조타입, 구조체는 값 타입이라서 이런거임

mutating func 를 써야하는 

- 원문
    
    Mutating key word has no meaning on classes
    
    ![스크린샷 2021-08-26 오후 3.55.04.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/65a4e45e-2e4f-41ff-aa5e-ae09e99242fd/스크린샷_2021-08-26_오후_3.55.04.png)
    
    ```swift
    struct TestValue {
        var a : Int = 42
    
        mutating func change() { a = 1975 }
    }
    
    let val = TestValue()
    val.a = 1710 // Forbidden because `val` is a `let` of a value type, so you can't mutate it
    val.change() // Also forbidden for the same reason
    
    class TestRef {
        var a : Int = 42
    
        func change() { a = 1975 }
    }
    
    let ref = TestRef()
    ref.a = 1710 // Allowed because `ref` is a reference type, even if it's a `let`
    ref.change() // Also allowed for the same reason
    ```
    

→ 아니 이렇게 보니깐 클래스보다 구조체가 못하는게 너무 많잖아

→ 그럼 구조체는 언제 사용할까?

**<구조체 사용이 유리한 경우> → 스위프트는 구조체 사용 권장 !**

1. 연관된 간단한 값의 집합을 **캡슐화**하는것만이 목적일 때
2. 캡슐화한 값을 참조하는 것보다 **복사**하는 것이 합당할 때
3. 구조체에 저장된 프로퍼티가 값 타입이며 참조하는 것보다 복사하는 것이 합당할 때
4. 다른 타입으로부터 상속받거나 자신을 **상속할 필요가 없을 때** 

→ 이런 몇가지 상황을 제외하고는 대부분 사용자 정의 데이터 타입은 클래스로 구현한다. 

→ Swift 대부분의 큰 뼈대는 구조체로 구성되어있는 반면, iOS 프레임워크의 대부분이 클래스로 구성된다.

### Class

- convenience init 사용 (stuct 의 경우 그냥 다른 init 또 사용가능)
- 이니셜라이저를 명시적으로 선언 필수 (struct는 암시적으로 선언된다)

![스크린샷 2021-08-24 오후 3.52.36.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/397f7272-0fbe-4ea4-ae60-cf5b7d0337b3/스크린샷_2021-08-24_오후_3.52.36.png)

![스크린샷 2021-08-24 오후 3.54.42.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5fde9209-a579-4bad-814c-5f6aa222c857/스크린샷_2021-08-24_오후_3.54.42.png)

## 일급시민( 일급객체) 가 뭐지?

### class 는 let 으로 선언된 인스턴스도 가변 프로퍼티의 값을 변경할 수 있다.

왜? 클래스는 참조 타입이기 때문이다. 

- 클래스에서 프로퍼티값을 변경할 때 (상수로 선언한) 인스턴스의 값이 바뀌는게 아니다
- 왜냐면 인스턴스들이 직접 값을 저장하고 있는게 아니기 때문이다
- 직접 값을 저장하는게 아니라, 안보이는 곳에서 실제 값을 가리키고 있다
- 프로퍼티 변경시 실제로 바뀌는 값은 원본 클래스의 프로퍼티이다
- class를 let / var로 인스턴스화하는것의 차이
    
    권나영님의 정리
    
    <aside>
    💡 class를 let / var로 인스턴스화하는것의 차이는? 무엇일까요?
    
    </aside>
    
    - stack over flow에서 찾은 답변
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1ce48931-4c95-40ef-bb97-a5182966f525/Untitled.png)
        
    
    - 기본적으로 let과 var 어느것으로 인스턴스를 만들어도, 둘 다 가변프로퍼티의 값을 변경할 수 있고 & 불변프로퍼티의 값을 변경 할 수 없다 는 사실은 같다
    - 차이점은 한 인스턴스에 다른 인스턴스를 할당 할수 있냐 / 없냐 의 차이입니다
        - let으로 선언시 → you cannot replace it with another instance 즉, 할당 불가능하다
        - 야곰은 이것을 `참조정보는 수정 불가능합니다` 라는 말로 표현했다 → 이말이 이해가 안가서
    
    - 이를 이해하기 위한 몇가지 실험들
        
        ```swift
        class Sample {
            var integer: Int = 100 // var로 선언한 가변 프로퍼티만 있는 클래스를 선언했어요
        }
        ```
        
    
    - 야곰이 말한 `참조정보는 수정 불가능합니다` 의 의미는
    - let 으로 선언한 인스턴스에 var로 선언한 인스턴스를 할당할 수 없다는 뜻입니다
        
        ```swift
        var mutableReference: Sample = Sample()
        let immutableReference: Sample = Sample()
        
        //ERROR 발생
        immutableReference = mutableReference // 여기를 보면 알수있죠!
        ```
        
        - [에러메세지]
            
            error: cannot assign to value: 'immutableReference' is a 'let' constant
            
            note: change 'let' to 'var' to make it mutable
            
            해석해보면 immutableReference는 let 상수입니다. 위 코드를 가능하게 하려면 var로 선언하세요!
            
    
    - 그러면 var로 선언한 인스턴스에 다른 상수/변수 인스턴스를 할당하는건 가능할까? 가능하다
        
        ```swift
        var mutableReference: Sample = Sample()
        let immutableReference: Sample = Sample()
        
        mutableReference = immutableReference // 에러안뜸 즉, 가능하다
        ```
        
        즉, 인스턴스를 var로 선언하면 다른 인스턴스를 할당할 수 있다 = 참조정보를 수정할 수 있다
        
    
    - 좀 더 확실하게 확인하고 싶다면: `===` 이용하기
        - `===`의 역할 → 두 변수/상수가 같은 인스턴스를 가리키고 있는지 확인하고 true / false로 알려줍니다
        
        ```swift
        // false! 다른 인스턴스를 가리키는 중입니다
        mutableReference === immutableReference 
        
        // 이렇게 할당해주고 밑에서 다시한번 같은 인스턴스를 참조하는지 확인해보면
        mutableReference = immutableReference  
        
        // true! 이제 둘은 같은 인스턴스를 참조합니다
        mutableReference === immutableReference 
        ```
        
    

`참조정보는 수정 불가능하다` = let 으로 선언한 인스턴스에 var로 선언한 인스턴스를 할당할 수 없다
