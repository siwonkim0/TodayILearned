# 학습내용

- 프로퍼티(속성)
- 매서드
- 상속
- 이니셜라이저

# 속성

: 구조체와 클래스 둘다 별로 차이 없음(매서드에서 상속과 관련있는 생성자 부분이 많이 차이남)

- 저장 속성
- 지연 저장 속성 `lazy var`
- 계산 속성 : 읽기 get / 쓰기 set
- **타입 속성 `static`**
    - 저장 타입 속성
    - 계산 타입 속성
- 속성 감시자

## 저장 속성

클래스, 구조체의 인스턴스가 가지는 고유의 저장 공간 (열거형에는 불가)

**객체 초기화시 반드시 값**이 있어야 한다 (기본값, 생성자, 옵셔널 셋중 하나는 무조건 해야함)

## 지연 저장 속성

**인스턴스 초기화 시점 ≠ 지연 저장 속성 초기화시점**

처음부터 초기화해야하지 않는 경우(메모리 절약 위해) 초기화를 지연시킨다
인스턴스 생성되고 나중에 값에 접근할 때 그제서야 초기화되며 메모리 공간이 생성된다
`lazy var` 만 가능
반드시 기본값이 필요하다 (생성자에서 초기화 안해서)
기본값은 꼭 숫자 X → 리턴값만 일치시 함수, 클로저, 등 다 가능 

- 왜 사용하나(2가지 이유)
    - 메모리 공간 절약
    - 지연 저장 속성(변수 b)이 다른 저장 속성(변수 a)을 이용할 때 : a가 먼저 존재해야 b를 사용가능

## 계산 속성

속성(변수)의 형태를 지녔지만, 실제로는 메서드(함수)의 역할과 동일하다.
→ 그래서 메모리 공간을 가지지 않고, 해당 속성에 접근시 다른 속성에 접근해서 계산한 후 그 결과를 리턴하거나 세팅하는 메서드임 

- 아니 그럼 왜 메서드랑 계산 속성이랑 두개가 있냐?
→ 메서드로도 구현이 가능하지만, 그러려면 2개의 매서드를 만들어야 해서 한번에 get / set 로 만들어 줄 수 있는 계산 속성을 사용하면 코드가 훨씬 깔끔해진다.

**`var`** 로만 선언 가능하고, **자료형**을 필수로 선언해야한다.(생략시 에러)

```swift
class Person {
    var name = "사람"
    var height = 160.0
    var weight = 60.0
    
    **var bmi: Double {**
        get {
                    return weight / ( height * height ) * 10000
        }
        set {
                    weight = newValue * height * height / 10000
        }
    **}**
}
var siwon : Person = Person()

siwon.bmi //get : 밖에서 그냥 계산된 값을 얻기 
siwon.bmi = 23.4 //set : 밖에서 값을 set (bmi 값 새로 변경해서 몸무게 변경하기)
```

### get

`get` 블록만 선언시 → 읽기 전용 계산 속성,`get{}` 블록 생략가능!
그래서 속성에 {} 이게 있다? 그러면 계산 속성이라고 알아봐야함 

```swift
class Person {
    var name = "사람"
    var height = 160.0
    var weight = 60.0
    
    **var bmi: Double {**
        return weight / ( height * height ) * 10000
    **}**
}
```

### set

`set` 블록은 선택적 구현 가능 → 근데 사용하려면 무조건 `get` 이랑 같이써야함 단독사용 NO
`set` 블록은 `newValue` 라는 기본 파라미터 제공 (설정 안하고 사용가능, 직접 딴이름으로 설정도 가능)

## 타입 속성

모든 인스턴스가 공유가 가능한 타입 자체에 속한 속성
따라서, [`Type.property`](http://type.property)로 접근해야함
외부 뿐만아니라 내부에서도 풀 네임으로 접근 
저장 타입 속성 주로 사용 (계산 타입은 별로...)

### 저장 타입 속성

모든 인스턴스가 동일하게 가져야하는 보편적인 속성이나 공유해야하는 성격에 가까운 저장속성을 저장 타입 속성으로 표현한다.
ex) Dog 타입에서 저장 타입 속성으로 표현할만 한 것은 동물종류: 개
모든 개는 개 종류니깐 dog1, dog2... 인스턴스가 공통으로 가지는 속성이잖아.

- `static` 를 기존 저장속성 앞에 붙여준다
- let / var 둘다 가능 (저장 속성이니 ~)
- 항상 기본값/초기값이 필요하다 → 생성자로 값 설정 안해줘서
- 지연(`lazy`) 속성의 성격을 가져서,, **호출시에 메모리를 할당**하게됨

```swift
class Dog {
    static let type = "Dog"
    static var count = 0
}

Dog.type //로 호출가능 -> 심지어 인스턴스 안 만들어도 호출가능 
```

### 계산 타입 속성

`static` 또는 `class` 키워드 사용
`class` 키워드 사용시 **상속시 재정의**가 가능하다(당연히 클래스만)
var 만 사용 가능 (계산 속성이니 ~)
메서드여서 타입에 메모리 공간이 할당이 안되어있음 (계산 속성이니 ~)

 

## 속성 감시자

저장 속성을 관찰하기위해 저장 속성 뒤에 달아 놓는 것 
(지연저장은 불가)
(아 계산 속성에도 상속 후 재정의시 할 수는 있는데....드물다 → 사실 계산속성의 set블럭도 동일한 역할 할수 있어서 그걸 사용하지)
사실 메서드임 ( 저장속성 변하는 순간에 관련 메서드가 호출)
저장 속성에 어떤 값이 들어있는지 항상 관찰하고 있으면서, 값이 바뀌면 그에 대해서 설명을 프린트해주는 역할을 한다. 

ex) 프로필 상메를 바꿨을 때 뭐에서 뭐로 바꿨는지 알려준다든가.. 
`var` 만 관찰 가능(let은 안변하니 어짜피)

아 그리고`newValue` `oldValue` 애플에서 기본적으로 제공하는 값이다. 바뀌고 나서 값이랑 바뀌기 전 값 파라미터 생성해서 해주기 귀찮으니깐

### willSet
메모리 변경 직전에 실행됨

### didSet
메모리가 변경되고 나서 실행됨 (실제론 didSet 를 주로 사용)
→ willSet, didSet 둘 중 하나만 사용하면 됨 

```swift
class Profile {
    var profileMessage: String = "기본값" {
        willSet {
            print("\(profileMessage)에서 \(newValue)로 변경됨") //변경 전 실행
        }
        didSet {
            print("\(oldValue)에서 \(profileMessage)로 변경됨") //변경 후 실행
        }
    }
    
}

let siwon = Profile()
siwon.profileMessage = "하..."
```

결과

![스크린샷 2021-09-02 오전 11.43.13.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6332a557-9097-48aa-ba9d-9ea0e9b0451f/스크린샷_2021-09-02_오전_11.43.13.png)

# 메서드

클래스, 구조체에 있는 함수

## 1) 인스턴스 메서드

메서드에서 인스턴스에 메모리공간이 할당되어있지 않다
 한 메서드에서 다른 메서드 호출도 가능 (self.method()나 method() 둘다 가능)

- 클래스에서는
기본적으로 자기 속성을 수정할 수 있어서 `mutating` 붙일 필요 없음

- 구조체에서는
기본적으로 인스턴스 메서드 내에서는 속성을 수정할 수 없으므로, 
만약 수정하고 싶다면 `mutating func` 라고 해줘야함
(구조체는 값 타입이므로)

**오버로딩 지원 (일반 함수와 동일하게)**

동일한 이름의 메서드를 여러개 만들 수 있음 
파라미터가 있고 없고로도 구분이된다

```swift
class Dog {
    var name: String = "천지"
    
    func sit() {
        print("\(name)가 앉았음")
    }
    func sit(no:String) {
        print("\(no)")
    }
}

var dog1 = Dog()
dog1.sit()
dog1.sit(no: "안돼!")
```

![스크린샷 2021-09-02 오후 12.16.53.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b31d6625-fb14-4c93-a7f6-676b7e1d86e7/스크린샷_2021-09-02_오후_12.16.53.png)

## 2) 타입 메서드

`static func` `class func` : **class 를 붙이면 상속시 재정의가 가능**하다 ~

*재정의란?: 부모 클래스에서 구현해놓은 내용을 살짝 바꿔서 사용하는 것 
타입 메서드도 내 외부에서 타입 속성처럼 **Type.method()** 이렇게 불러야함 
 타입 메서드에서는 타입 저장속성의 값을 가져올 때 타입 생략가능
→ `Dog.species` , `species` 둘다가능

ex)

`Int.random(in: 1...100)`
`Double.random(in: 1.1...100.2)`
랜덤값을 뽑아내는 Int, Double 타입의 random 메서드
: 모든 정수가 랜덤값 뽑기 가능하기 때문에 타입 메서드임 

## 3) 서브스크립트

대괄호를 사용할 수 있는 문법 → 이것도 메서드임 사실 (그래서 우리가 구현도 가능)
헐! 배열이나 딕셔너리에서 쓰던 것이 바로 이것임

`array[0]`, `dictionary["A"]`

클래스에서 구현 가능 → 계산 속성과 사실 유사 (get / set ) 있음
원래 클래스에서 가능했던
인스턴스.0
인스턴스.method() 가 아니라
인스턴스[파라미터] 형태로 만들고 싶다 

```swift
class SomeData {
    var datas = ["Apple", "Swift", "iOS", "Hello"]

    
    subscript(index: Int) -> String {    
        get {  // get/set은 계산속성과 비슷
            return datas[index]
        }
        set(parameterName) {
            datas[index] = parameterName  // 파라미터 생략하고 newValue로 대체 가능(계산 속성의 setter와 동일)
        }
    }
    
}

var data = SomeData()
data[0]
data[0] = "AAA"
```
